# DON'T EDIT THIS FILE
# If you would like a common place to put things, please create a ~/.localrc
# since this file will include it after all variables are defined.

# Define the WORKON_HOME for virtualenv
if [ -z "$WORKON_HOME" ]; then
    export WORKON_HOME=$HOME/.virtualenvs
fi

# Define the PROJECT_HOME for virtualenv
if [ -z "$PROJECT_HOME" ]; then
    export PROJECT_HOME=$HOME/Projects
fi

# vendor/bin/ for composer projects - see http://getcomposer.org
# ~/.local/bin for local stuffs
export PATH=./vendor/bin:$HOME/.composer/vendor/bin:$HOME/.local/bin:$PATH

# export pyenv environment
if [ -z "$PYENV_ROOT" ]; then
    export PYENV_ROOT="$HOME/.pyenv"
fi

# Setup phpenv if it exists
if [ -d "$HOME/.phpenv/bin" ]; then
    export PATH="$HOME/.phpenv/bin/:$PATH"
    eval "$(phpenv init -)"
fi

# Capture output using trace
function __eg_capture() {
    if [[ $OSTYPE = (darwin)* ]]; then
        sudo dtrace -p "$1" -qn '
            syscall::write*:entry
            /pid == $target && arg0 == 1/ {
                printf("%s", copyinstr(arg1, arg2));
            }
        '
    elif [[ $OSTYPE = (linux)* ]]; then
        sudo strace -p"$1" -s9999 -e write
    fi
}

alias capture=__eg_capture

if [[ $OSTYPE = (darwin)* ]]; then
    function __eg_mysql() {
        if [ -z "$1" ] && [ -z "$EG_MYSQL_OLD_PATH" ]; then
            echo "You must specify the MySQL version";
            return;
        elif [ ! -z "$1" ] && [ ! -d "/usr/local/opt/mysql@${1}" ]; then
            echo "MySQL version ${1} is not installed";
            return;
        fi

        version="$1"

        if [ ! -z "$EG_MYSQL_OLD_PATH" ]; then
            export PATH="$EG_MYSQL_OLD_PATH"
            unset EG_MYSQL_OLD_PATH
        fi

        if [ ! -z "$version" ]; then
            export EG_MYSQL_OLD_PATH="$PATH"
            export PATH="/usr/local/opt/mysql@${version}/bin:$PATH"
        fi
    }

    alias mysqlenv=__eg_mysql
fi

###
# Combines `ps` and `grep` to easily search processes. To pass arguments to ps
# place them before the search term: `__eg_psgrep aux httpd` Simply calling the
# function and passing a search term will execute `ps aux`
##
function __eg_psgrep()
{
    search=${@:$#}

    if [ "$#" -eq 1 ]
    then
        ps aux | head -n1; ps aux | grep -v grep | grep --color=always $search
    else
        # keep the space here for zsh
        # https://stackoverflow.com/questions/1215538/extract-parameters-before-last-parameter-in#comment112570591_1215592
        args=${@:1:$# -1}
        echo "${args}" | xargs ps | head -n1; echo "${args}" | xargs ps | grep -v grep | grep --color=always $search
    fi

}

# make easier use of the awesomeness
alias psgrep=__eg_psgrep

function __es_pssize()
{
    search=${@:$#}

    if [ "$#" -eq 1 ]; then
        command=(__eg_psgrep -eo size,pid,user,command --sort -size $search)
    else
        command=(ps -eo size,pid,user,command --sort -size)
    fi

    "${command[@]}" | awk '{ hr=$1/1024 ; printf("%13.2f Mb ",hr) } { for ( x=2 ; x<=NF ; x++ ) { printf("%s ",$x) } print "" }'
}

alias pssize=__es_pssize

if [ -z "$EDITOR" ] && (( $+commands[vim] )) ; then
    export EDITOR=$(which vim)
fi

# Import any local configs
[ -f ~/.localrc ] && source ~/.localrc

# Add RVM to PATH for scripting. Make sure this is the last PATH variable change.
if [ -d "$HOME/.rvm/bin" ]; then
    export PATH="$PATH:$HOME/.rvm/bin"

    [[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm" # Load RVM into a shell session *as a function*
fi

# If zsh, make sure our path is unique
if [ "$0" = "zsh" ]; then
    export -U PATH="$PATH"
fi
